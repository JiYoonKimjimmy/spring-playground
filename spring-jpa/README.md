# Hello, Spring Data JPA!

- Entity 관리
- Transaction 관리
- Optimistic Lock(낙관적 락) vs Pessimistic Lock(비관적 락)
- Dynamic Query 지원 라이브러리
  - QueryDSL
  - KotlinJDSL
- Paging Query 처리 
  - 페이징 쿼리 성능 이슈 & 최적화 방법
- **Exposed** 적용 검토

---

## Entity 관리

- **영속성 컨텍스트 관리**
- **엔티티 관계 매핑**
- **2차 캐시**
- **`N+1` 문제**

### Persistence Context 영속성 컨텍스트

`Persistence Context` **영속성 컨텍스트**는 Entity 엔티티 객체를 관리하고,
데이터베이스와의 상호작용을 중재하는 역할을 한다.

- 엔티티 객체의 상태를 추적하고,
- 데이터베이스와의 동기화를 관리하며,
- 데이터 일관성을 유지하고,
- 성능을 최적화할 수 있다.

#### 영속성 관리

- 엔티티의 영속성은 `@Id` 정보 기준으로 관리된다.
- 영속성 컨텍스트에 영속화된 엔티티는 `@Id` 정보 조건으로 다시 조회하더라도 동일한 엔티티를 반환한다.
  - 하지만, 다른 컬럼(프로퍼티) 조건으로 조회하는 경우 다시 `select` 쿼리가 수행된다.

##### `@Transactional` 애노테이션과 관계

- 영속화된 엔티티에 변경이 발생한 경우, `Dirty Checking` 을 통해서 영속성 컨텍스트는 엔티티의 변경을 감지한다.
- `@Transactional` 애노테이션이 선언되어 있는 함수에서 엔티티의 변경 정보는 트랜잭션 커밋 순간 `update` 쿼리가 수행된다.
- 하지만 `@Transactional` 애노테이션 없이 명시적으로 `save()` 함수로 엔티티 변경을 반영하는 함수에서는 `select > update` 쿼리가 수행된다.
  - 이 경우 엔티티가 실제 DB 존재 여부 확인을 위해 `select` 쿼리가 먼저 수행된다.

---

### Entity Relation Mapping 엔티티 관계 매핑

RDBMS 관계형 데이터베이스를 사용한다면 테이블 관계를 맺고 관리할 것이다.
`JPA` 와 같은 ORM 프레임워크에서 RDB 의 테이블 관계를 **엔티티 관계 매핑**으로 객체 모델을 표현하고,
다양한 기능을 제공하고 있다.

- 엔티티 관계 매핑 유형
- 엔티티 관계 매핑 종류
- `Fetch` 전략
- `Cascade` 옵션

#### 엔티티 관계 매핑 유형

엔티티 간의 관계 매핑은 **단방향** 또는 **양방향** 관계로 설정할 수 있다.

- **단방향 관계** : 하나의 엔티티만 다른 엔티티를 참조하는 관계
- **양방향 관계** : 두 개의 엔티티 모두 서로를 참조하는 관계

다른 엔티티가 관계를 맺지만, 각 엔티티의 관계에는 **주인이 존재한다.**
**연관 관계의 주인은 DB 테이블 상 `Foreign Key 외래-키`를 가지고 있는 엔티티가 된다.**

##### 외래-키를 가진 엔티티가 연관관계의 주인이 되어야 하는 이유

> [참고 : 성장하는 성하 Blog - [JPA] JPA 1:N 관계에서 연관관계 주인을 1 대신 N에 두는 이유](https://ksh-coding.tistory.com/112)

###### 1. 불필요한 `update` 쿼리 수행

`1:N` 부모-자식 관계에서 외래-키는 **자식 엔티티**에 존재하는 상태에서, 
만약 연관 관계의 주인이 부모 엔티티로 설정한다면, 자식 엔티티가 생성될 때 불필요한 `update` 쿼리가 수행된다.

1. 자식 엔티티가 생성될 때, 외래-키 값이 없는 상태로 `insert` 쿼리가 수행되면서 생성된다.
2. 부모 엔티티가 생성되고, 부모 엔티티의 `PK` 값을 자식 엔티티의 외래-키 값으로 설정한다.
3. 외래-키 값이 설정된 자식 엔티티의 `update` 쿼리가 한번 더 수행된다.

###### 2. 상태가 변경된 엔티티 != 수행되는 쿼리 대상 테이블

`1:N` 부모-자식 관계에서 부모 엔티티의 상태 변경, 즉 자식 엔티티를 추가하게 되면
**자식 엔티티 테이블의 `update` 쿼리가 수행된다.**

애플리케이션 코드에서는 부모 엔티티 객체를 수정하였지만, 정작 쿼리는 자식 엔티티 테이블으로 불일치하게 된다.

이런 부분은 추후 애플리케이션의 규모가 점점 커질 수록 유지보수성을 떨어트리는 요인이 될 수 있다.

> ##### 연관관계의 주인 엔티티의 역할
> 외래-키를 가진 엔티티가 연관관계의 주인이 된다면, 외래-키 관계 매핑된 엔티티의 데이터를 관리한다.

#### 엔티티 관계 매핑 종류

|      종류       |    설명    |
|:-------------:|:--------:|
|  `@OneToOne`  | `1:1` 관계 |
| `@OneToMany`  | `1:N` 관계 |
| `@ManyToOne`  | `N:1` 관계 |
| `@ManyToMany` | `N:N` 관계 |

#### `Cascade` 영속성 전이

|    종류     |             설명             |
|:---------:|:--------------------------:|
|   `ALL`   |      모든 Cascade 타입 적용      |
| `PERSIST` |    엔티티 저장 시 연관된 엔티티도 저장    |
|  `MERGE`  |    엔티티 병합 시 연관된 엔티티도 병합    |
| `REMOVE`  |    엔티티 삭제 시 연관된 엔티티도 삭제    |
| `REFRESH` | 엔티티 새로 고침 시 연관된 엔티티도 새로 고침 |
| `DETACH`  |    엔티티 분리 시 연관된 엔티티도 분리    |

##### `detached entity passed to persist` 에러 발생

DB 저장 완료된 엔티티를 다시 한번 저장하려고 한다면, `detached entity passed to persist` 에러 발생한다.

이미 한번 `save()` 함수를 통해 저장된 엔티티는 `@Id` 값이 `null` 이 아니기 때문에 
해당 엔티티의 영속성 상태를 `DETACHED` **준영속성** 상태로 판단하게 된다.

하지만, 만약 준영속성인 자식 엔티티를 가진 부모 엔티티를 저장할 때, 자식 엔티티에 대한 영속성 전이 옵션이 `Cascade.ALL` 인 경우,
**준영속성 상태 였던 자식 엔티티를 다시 한번 저장하게 되어** 위와 같은 에러가 발생하게 된다.

#### `Fetch` 전략


---