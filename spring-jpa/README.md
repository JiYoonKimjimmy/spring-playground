# Hello, Spring Data JPA!

- Entity 관리
- Transaction 관리
- Optimistic Lock(낙관적 락) vs Pessimistic Lock(비관적 락)
- Dynamic Query 지원 라이브러리
  - QueryDSL
  - KotlinJDSL
- Paging Query 처리 
  - 페이징 쿼리 성능 이슈 & 최적화 방법
- **Exposed** 적용 검토

---

## Entity 관리

- **영속성 컨텍스트 관리**
- **엔티티 관계 매핑**
- **1차 & 2차 캐시**
- **`N+1` 문제**

### Persistence Context 영속성 컨텍스트

`Persistence Context` **영속성 컨텍스트**는 Entity 엔티티 객체를 관리하고,
데이터베이스와의 상호작용을 중재하는 역할을 한다.

- 엔티티 객체의 상태를 추적하고,
- 데이터베이스와의 동기화를 관리하며,
- 데이터 일관성을 유지하고,
- 성능을 최적화할 수 있다.

#### 영속성 관리

- 엔티티의 영속성은 `@Id` 정보 기준으로 관리된다.
- 영속성 컨텍스트에 영속화된 엔티티는 `@Id` 정보 조건으로 다시 조회하더라도 동일한 엔티티를 반환한다.
  - 하지만, 다른 컬럼(프로퍼티) 조건으로 조회하는 경우 다시 `select` 쿼리가 수행된다.

##### `@Transactional` 애노테이션과 관계

- 영속화된 엔티티에 변경이 발생한 경우, `Dirty Checking` 을 통해서 영속성 컨텍스트는 엔티티의 변경을 감지한다.
- `@Transactional` 애노테이션이 선언되어 있는 함수에서 엔티티의 변경 정보는 트랜잭션 커밋 순간 `update` 쿼리가 수행된다.
- 하지만 `@Transactional` 애노테이션 없이 명시적으로 `save()` 함수로 엔티티 변경을 반영하는 함수에서는 `select > update` 쿼리가 수행된다.
  - 이 경우 엔티티가 실제 DB 존재 여부 확인을 위해 `select` 쿼리가 먼저 수행된다.

---

### Entity Relation Mapping 엔티티 관계 매핑

RDBMS 관계형 데이터베이스를 사용한다면 테이블 관계를 맺고 관리할 것이다.
`JPA` 와 같은 ORM 프레임워크에서 RDB 의 테이블 관계를 **엔티티 관계 매핑**으로 객체 모델을 표현하고,
다양한 기능을 제공하고 있다.

- 엔티티 관계 매핑 유형
- 엔티티 관계 매핑 종류
- `Fetch` 전략
- `Cascade` 옵션

#### 엔티티 관계 매핑 유형

엔티티 간의 관계 매핑은 **단방향** 또는 **양방향** 관계로 설정할 수 있다.

- **단방향 관계** : 하나의 엔티티만 다른 엔티티를 참조하는 관계
- **양방향 관계** : 두 개의 엔티티 모두 서로를 참조하는 관계

다른 엔티티가 관계를 맺지만, 각 엔티티의 관계에는 **주인이 존재한다.**
**연관 관계의 주인은 DB 테이블 상 `Foreign Key 외래-키`를 가지고 있는 엔티티가 된다.**

##### 외래-키를 가진 엔티티가 연관관계의 주인이 되어야 하는 이유

> [참고 : 성장하는 성하 Blog - [JPA] JPA 1:N 관계에서 연관관계 주인을 1 대신 N에 두는 이유](https://ksh-coding.tistory.com/112)

###### 1. 불필요한 `update` 쿼리 수행

`1:N` 부모-자식 관계에서 외래-키는 **자식 엔티티**에 존재하는 상태에서, 
만약 연관 관계의 주인이 부모 엔티티로 설정한다면, 자식 엔티티가 생성될 때 불필요한 `update` 쿼리가 수행된다.

1. 자식 엔티티가 생성될 때, 외래-키 값이 없는 상태로 `insert` 쿼리가 수행되면서 생성된다.
2. 부모 엔티티가 생성되고, 부모 엔티티의 `PK` 값을 자식 엔티티의 외래-키 값으로 설정한다.
3. 외래-키 값이 설정된 자식 엔티티의 `update` 쿼리가 한번 더 수행된다.

###### 2. 상태가 변경된 엔티티 != 수행되는 쿼리 대상 테이블

`1:N` 부모-자식 관계에서 부모 엔티티의 상태 변경, 즉 자식 엔티티를 추가하게 되면
**자식 엔티티 테이블의 `update` 쿼리가 수행된다.**

애플리케이션 코드에서는 부모 엔티티 객체를 수정하였지만, 정작 쿼리는 자식 엔티티 테이블으로 불일치하게 된다.

이런 부분은 추후 애플리케이션의 규모가 점점 커질 수록 유지보수성을 떨어트리는 요인이 될 수 있다.

> ##### 연관관계의 주인 엔티티의 역할
> 외래-키를 가진 엔티티가 연관관계의 주인이 된다면, 외래-키 관계 매핑된 엔티티의 데이터를 관리한다.

#### 엔티티 관계 매핑 종류

|      종류       |    설명    |
|:-------------:|:--------:|
|  `@OneToOne`  | `1:1` 관계 |
| `@OneToMany`  | `1:N` 관계 |
| `@ManyToOne`  | `N:1` 관계 |
| `@ManyToMany` | `N:N` 관계 |

#### `Cascade` 영속성 전이

- `Cascade` **영속성 전이** 옵션은 특정 엔티티를 영속 상태로 만들 때, 연관된 엔티티의 영속성 상태를 관리하는 옵션이다.
- `Cascade` 옵션은 여러 종류가 있으며, 각 종류별로 동작 방식 차이가 있다.

|    종류     |               설명                |
|:---------:|:-------------------------------:|
| `PERSIST` |    엔티티 **저장 시,** 연관된 엔티티도 저장    |
|  `MERGE`  |    엔티티 **병합 시,** 연관된 엔티티도 병합    |
| `REMOVE`  |    엔티티 **삭제 시,** 연관된 엔티티도 삭제    |
| `REFRESH` | 엔티티 **새로 고침 시**, 연관된 엔티티도 새로 고침 |
| `DETACH`  |    엔티티 **분리 시,** 연관된 엔티티도 분리    |
|   `ALL`   |      **모든 Cascade 타입 적용**       |

##### `detached entity passed to persist` 에러 발생

DB 저장 완료된 엔티티를 다시 한번 저장하려고 한다면, `detached entity passed to persist` 에러 발생한다.

이미 한번 `save()` 함수를 통해 저장된 엔티티는 `@Id` 값이 `null` 이 아니기 때문에 
해당 엔티티의 영속성 상태를 `DETACHED` **준영속성** 상태로 판단하게 된다.

하지만, 만약 준영속성인 자식 엔티티를 가진 부모 엔티티를 저장할 때, 자식 엔티티에 대한 영속성 전이 옵션이 `Cascade.ALL` 인 경우,
**준영속성 상태 였던 자식 엔티티를 다시 한번 저장하게 되어** 위와 같은 에러가 발생하게 된다.

#### `Fetch` 전략

**`Fetch` 전략**은 엔티티 관계 매핑에서 연관된 엔티티를 조회할 때 사용하는 전략으로, **`EAGER` 또는 `LAZY`** 2가지 전략 종류가 있다.

##### `EAGER` 전략

- **`EAGER` 즉시 로딩** 전략은 엔티티를 조회할 때, 연관된 엔티티를 함께 조회하는 전략이다.
- 필용한 연관 관계의 엔티티를 `Join` 쿼리를 사용하여 즉시 조회할 수 있다.
- 하지만, 불필요한 엔티티를 동시 조회하기 때문에 쿼리 성능 영향이 있을 수 있다.
- **`@OneToOne`, `@ManyToOne` 연관 관계에서 기본 설정이다.**
- `EAGER` 전략은 연관 관계의 엔티티가 항상 필요하고, 연관 관계의 엔티티의 수가 적을 때 사용하는 것이 유용하다.

##### `LAZY` 전략

- **`LAZY` 지연 로딩** 전략은 엔티티를 조회할 때, 연관된 엔티티를 함께 조회하지 않는 전략이다.
- 연관된 엔티티를 실제로 사용하는 시점에 조회하는 전략이다.
- 필요한 연관 관계의 엔티티를 실제로 사용하는 시점에 조회하기 때문에 쿼리 성능 영향이 적다.
- 하지만, 연관 관계의 엔티티를 접근할 때 추가적인 쿼리가 발생하기 때문에 DB Access Connection 횟수 이슈가 발생할 수 있다.
- **`@OneToMany`, `@ManyToMany` 연관 관계에에서 기본 설정이다.**
- `LAZY` 전략은 연관 관계의 엔티티가 항상 필요하지 않고, 연관 관계의 엔티티의 수가 많을 때 사용하는 것이 유용하다.

---

### 1차 & 2차 캐시

#### 1차 캐시

- **1차 캐시**는 `EntityManager` 엔티티 매니저에 의해 관리되는 캐시로, 영속성 컨텍스트 내부에서 존재하는 캐시이다.
- 동일한 트랜잭션 내에서 동일한 엔티티를 여러 번 조회할 때 조회 성능을 향상시키기 위한 캐시이다.
- 해당 트랜잭션이 종료되면 **1차 캐시도 함께 제거된다.**

#### 2차 캐시

- **2차 캐시**는 엔티티 매니저 팩토리에 의해 관리되는 캐시로, 여러 엔티티 매니저에서 공유되는 캐시이다.
- 여러 트랜잭션이나 여러 엔티티 매니저에서 동일한 엔티티를 공유하여 조회 성능을 향상시키기 위한 캐시이다.
- 트랜잭션이 종료되더라도 2차 캐시는 존재하며, **애플리케이션 종료되면 2차 캐시도 제거된다.**

> #### Spring Data JPA 캐시 관리
> - Spring Data JPA 에서의 캐시는 엔티티에 선언된 `@Id` 프로퍼티를 `Key` 로 사용하여 캐시 관리한다.
> - `@Id` 프로퍼티 값이 아닌 다른 프로퍼티(컬럼) 조건으로 조회하는 경우 캐시가 동작하지 않는다.

##### 2차 캐시 설정 방법

- 2차 캐시는 Spring 의 Properties 파일을 통해 설정할 수 있다.
- 2차 캐시 제공자로는 `EhCache`, `Hazelcast`, `Infinispan`, `Coherence`, `Caffeine` 등 다양한 캐시 라이브러리를 활용할 수 있다.

```yaml
spring:
  jpa:
    properties:
      hibernate:
        cache:
          use_second_level_cache: true
          region:
            factory_class: org.hibernate.cache.ehcache.EhCacheRegionFactory
```

##### 2차 캐시 주의 사항

- 데이터 일관성 문제 : 캐시가 즉시 업데이트되지 않아 데이터 일관성 문제가 발생할 수 있다.
- 메모리 사용 증가 : 저장하는 캐시 데이터의 크기에 따라 메모리 사용량이 증가할 수 있다.
- 캐시 오버헤드 : 데이터가 큰 캐시를 자주 갱신되거나 제거되는 경우 성능적인 이점이 감소할 수 있다.
- 적용 범위 제한 : 자주 변경되는 실시간 데이터는 2차 캐시 사용에 부적절할 수 있다.

---

#### `N+1` 문제

- `N+1` 문제는 `LAZY` 전략 사용할 때 발생하는 성능 이슈이다.
- 예를 들어, `1 : N` 관계에서 `1` 엔티티를 조회할 때, `N` 엔티티를 함께 조회하지 않는다.
- 하지만, `1` 엔티티를 조회한 이후, `N` 엔티티를 조회하는 추가적인 쿼리가 발생하게 된다.
- 이러한 추가적인 쿼리가 발생하는 것을 `N+1` 문제라고 한다.
- 이러한 문제를 해결하기 위해서는 `Fetch Join` 또는 `EntityGraph` 옵션을 사용하여 해결할 수 있다.

##### Fetch Join

- `Fetch Join` 옵션은 엔티티 관계 매핑에서 연관된 엔티티를 함께 조회하는 옵션이다.
- `Fetch Join` 옵션은 `@OneToMany`, `@ManyToMany` 연관 관계에서 사용된다.
- `Fetch Join` 옵션은 연관된 엔티티를 함께 조회하기 때문에 `N+1` 문제를 해결할 수 있다.
- 하지만, `Fetch Join` 옵션은 연관된 엔티티를 함께 조회하기 때문에 쿼리 성능 영향이 있을 수 있다.

##### EntityGraph

- `EntityGraph` 설정을 통해 엔티티를 조회할 때 `Fetch` 전략을 동적으로 설정할 수 있다.
- `N+1` 문제 해결 : `LAZY` 전략의 연관 관계의 엔티티를 필요한 상황에 따라 `EAGER` 전략 조회하여 `N+1` 문제를 해결할 수 있다.
- 특정 엔티티 조건부 즉시 로딩 : 모든 연관 관계의 엔티티를 즉시 로딩하는 것이 아니라 필요한 연관된 엔티티만 조회할 수 있다.
- 다양한 `EntityGraph` 설정 : 다양한 비즈니스 로직에 따른 `EntityGraph` 설정을 분리하여 관리할 수 있다.

---
